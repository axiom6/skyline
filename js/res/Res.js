// Generated by CoffeeScript 1.12.2
(function() {
  var Data, Res, UI,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  Data = require('js/res/Data');

  UI = require('js/res/UI');

  Res = (function() {
    module.exports = Res;

    Res.Rooms = require('data/room.json');

    Res.Sets = ['full', 'book', 'resv', 'chan'];

    function Res(stream, store, appName) {
      this.stream = stream;
      this.store = store;
      this.appName = appName;
      this.select = bind(this.select, this);
      this.insert = bind(this.insert, this);
      this.onDay = bind(this.onDay, this);
      this.onRes = bind(this.onRes, this);
      this.selectAllDaysResvs = bind(this.selectAllDaysResvs, this);
      this.selectAllResvs = bind(this.selectAllResvs, this);
      this.rooms = Res.Rooms;
      this.roomKeys = Util.keys(this.rooms);
      this.book = null;
      this.master = null;
      this.days = {};
      this.resvs = {};
      this.cans = {};
      this.order = 'Decend';
      this.today = Data.today();
    }

    Res.prototype.dateRange = function(beg, end, onComplete) {
      if (onComplete == null) {
        onComplete = null;
      }
      this.store.subscribe('Day', 'range', 'none', (function(_this) {
        return function(days) {
          var day, dayId, ref;
          _this.days = days;
          ref = _this.days;
          for (dayId in ref) {
            if (!hasProp.call(ref, dayId)) continue;
            day = ref[dayId];
            day.status = Data.toStatus(day.status);
          }
          if (Util.isFunc(onComplete)) {
            return onComplete();
          }
        };
      })(this));
      this.store.range('Day', beg + '1', end + 'S');
    };

    Res.prototype.selectAllDays = function(onComplete) {
      if (onComplete == null) {
        onComplete = null;
      }
      this.store.subscribe('Day', 'select', 'none', (function(_this) {
        return function(days) {
          _this.days = days;
          if (Util.isFunc(onComplete)) {
            return onComplete();
          }
        };
      })(this));
      this.store.select('Day');
    };

    Res.prototype.selectAllResvs = function(onComplete, genDays) {
      if (onComplete == null) {
        onComplete = null;
      }
      if (genDays == null) {
        genDays = false;
      }
      this.store.subscribe('Res', 'select', 'none', (function(_this) {
        return function(resvs) {
          var ref, resId, resv;
          _this.resvs = resvs;
          if (genDays) {
            ref = _this.resvs;
            for (resId in ref) {
              if (!hasProp.call(ref, resId)) continue;
              resv = ref[resId];
              _this.updateDaysFromResv(resv, false);
            }
          }
          if (Util.isFunc(onComplete)) {
            return onComplete();
          }
        };
      })(this));
      this.store.select('Res');
    };

    Res.prototype.selectAllDaysResvs = function(onComplete) {
      if (onComplete == null) {
        onComplete = null;
      }
      this.selectAllDays((function(_this) {
        return function() {
          return _this.selectAllResvs(onComplete);
        };
      })(this));
    };

    Res.prototype.roomUI = function(rooms) {
      var key, room;
      for (key in rooms) {
        if (!hasProp.call(rooms, key)) continue;
        room = rooms[key];
        room.$ = {};
        room = this.populateRoom(room, {}, 0, 0, 2, 0);
      }
    };

    Res.prototype.populateRoom = function(room, days, total, price, guests, pets) {
      room.days = days;
      room.total = total;
      room.price = price;
      room.guests = guests;
      room.pets = pets;
      room.change = 0;
      room.reason = 'No Changes';
      return room;
    };

    Res.prototype.isNewResv = function(resv) {
      var nights;
      nights = Data.nights(resv.booked, this.today);
      return nights < Data.newDays;
    };

    Res.prototype.status = function(date, roomId) {
      var day, dayId, st;
      if (roomId === 0) {
        return 'Free';
      }
      dayId = Data.dayId(date, roomId);
      day = this.days[dayId];
      st = day != null ? day.status : 'Free';
      return st;
    };

    Res.prototype.klass = function(date, roomId) {
      var resv, status;
      resv = this.getResv(date, roomId);
      status = 'Free';
      if (resv != null) {
        status = resv.status;
        if (this.isNewResv(resv)) {
          if (status === 'Skyline' || status === 'book') {
            status = 'SkylNew';
          }
          if (status === 'Booking' || status === 'chan') {
            status = 'BookNew';
          }
        }
      } else {
        status = this.status(date, roomId);
      }
      return status;
    };

    Res.prototype.getResv = function(date, roomId) {
      var day;
      day = this.day(date, roomId);
      if (day != null) {
        return this.resvs[day.resId];
      } else {
        return null;
      }
    };

    Res.prototype.day = function(date, roomId) {
      var day, dayId;
      dayId = Data.dayId(date, roomId);
      day = this.days[dayId];
      if (day != null) {
        return day;
      } else {
        return this.setDay({}, 'Free', 'none', dayId);
      }
    };

    Res.prototype.dayIds = function(arrive, stayto, roomId) {
      var i, ids, j, nights, ref;
      nights = Data.nights(arrive, stayto);
      ids = [];
      for (i = j = 0, ref = nights; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        ids.push(Data.dayId(Data.advanceDate(arrive, i), roomId));
      }
      return ids;
    };

    Res.prototype.datesFree = function(arrive, stayto, roomId, resv) {
      var dayId, dayIds, j, len;
      dayIds = this.dayIds(arrive, stayto, roomId);
      for (j = 0, len = dayIds.length; j < len; j++) {
        dayId = dayIds[j];
        if ((this.days[dayId] != null) && !(this.days[dayId].status === 'Free' || this.days[dayId].resId === resv.resId)) {
          Util.log('Res.collision days', {
            arrive: arrive,
            stayto: stayto,
            roomId: roomId,
            dayId: dayId
          });
          Util.log('Res.collision resv', {
            arrive: resv.arrive,
            stayto: resv.stayto,
            roomId: resv.roomId,
            name: resv.last
          });
          return false;
        }
      }
      return true;
    };

    Res.prototype.allocDays = function(days) {
      if (this.book != null) {
        this.book.allocDays(days);
      }
      if (this.master != null) {
        this.master.allocDays(days);
      }
    };

    Res.prototype.updateResvs = function(newResvs) {
      var resId, resv;
      for (resId in newResvs) {
        if (!hasProp.call(newResvs, resId)) continue;
        resv = newResvs[resId];
        this.addResv(resv);
      }
      return this.resvs;
    };

    Res.prototype.updateCancels = function(newCancels) {
      var can, resId;
      for (resId in newCancels) {
        if (!hasProp.call(newCancels, resId)) continue;
        can = newCancels[resId];
        this.addCan(can);
      }
      return this.resvs;
    };

    Res.prototype.isResvDay = function(day, resv) {
      return (day != null) && day.resId === resv.resId;
    };

    Res.prototype.daysFromResv = function(resv) {
      var dayId, days, i, j, ref;
      days = {};
      for (i = j = 0, ref = resv.nights; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        dayId = Data.dayId(Data.advanceDate(resv.arrive, i), resv.roomId);
        days[dayId] = this.isResvDay(this.days[dayId], resv) ? this.days[dayId] : this.setDay({}, resv.status, resv.resId, dayId);
      }
      return days;
    };

    Res.prototype.deleteDaysFromResv = function(resv) {
      var day, dayId, days;
      days = this.daysFromResv(resv);
      for (dayId in days) {
        day = days[dayId];
        day.status = 'Free';
      }
      this.allocDays(days);
      for (dayId in days) {
        day = days[dayId];
        this.delDay(day);
      }
    };

    Res.prototype.updateDaysFromResv = function(resv, add) {
      var day, dayId, days;
      if (add == null) {
        add = true;
      }
      days = this.daysFromResv(resv);
      this.allocDays(days);
      if (add) {
        for (dayId in days) {
          day = days[dayId];
          this.addDay(day);
        }
      }
    };

    Res.prototype.calcPrice = function(roomId, guests, pets, status) {
      if (status === 'Booking' || status === 'Prepaid') {
        return this.rooms[roomId].booking;
      } else {
        return this.rooms[roomId][guests] + pets * Data.petPrice;
      }
    };

    Res.prototype.spaOptOut = function(roomId, isSpaOptOut) {
      if (isSpaOptOut == null) {
        isSpaOptOut = true;
      }
      if (this.rooms[roomId].spa === 'O' && isSpaOptOut) {
        return Data.spaOptOut;
      } else {
        return 0;
      }
    };

    Res.prototype.genDates = function(arrive, nights) {
      var date, dates, i, j, ref;
      dates = {};
      for (i = j = 0, ref = nights; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        date = Data.advanceDate(arrive, i);
        dates[date] = "";
      }
      return dates;
    };

    Res.prototype.total = function(status, nights, roomId, guests, pets) {
      var tot;
      if (pets == null) {
        pets = 0;
      }
      tot = 0;
      if (status === 'Skyline') {
        tot = nights * (this.rooms[roomId][guests] + pets * Data.petPrice);
      } else {
        tot = nights * this.rooms[roomId].booking;
      }
      return tot;
    };

    Res.prototype.createResvSkyline = function(arrive, stayto, roomId, last, status, guests, pets, spa, cust, payments) {
      var booked, nights, price, total;
      if (spa == null) {
        spa = false;
      }
      if (cust == null) {
        cust = {};
      }
      if (payments == null) {
        payments = {};
      }
      booked = Data.today();
      price = this.rooms[roomId][guests] + pets * Data.petPrice;
      nights = Data.nights(arrive, stayto);
      total = price * nights;
      return this.createResv(arrive, stayto, booked, roomId, last, status, guests, pets, 'Skyline', total, spa, cust, payments);
    };

    Res.prototype.createResvBooking = function(arrive, stayto, roomId, last, status, guests, total, booked) {
      var pets;
      total = total === 0 ? this.rooms[roomId].booking * Data.nights(arrive, stayto) : total;
      pets = 0;
      return this.createResv(arrive, stayto, booked, roomId, last, status, guests, pets, 'Booking', total);
    };

    Res.prototype.createResv = function(arrive, stayto, booked, roomId, last, status, guests, pets, source, total, spa, cust, payments) {
      var resv;
      if (spa == null) {
        spa = false;
      }
      if (cust == null) {
        cust = {};
      }
      if (payments == null) {
        payments = {};
      }
      resv = {};
      resv.nights = Data.nights(arrive, stayto);
      resv.arrive = arrive;
      resv.stayto = stayto;
      resv.depart = Data.advanceDate(stayto, 1);
      resv.booked = booked;
      resv.roomId = roomId;
      resv.last = last;
      resv.status = status;
      resv.guests = guests;
      resv.pets = pets;
      resv.source = source;
      resv.resId = Data.resId(arrive, roomId);
      resv.total = total;
      resv.price = total / resv.nights;
      resv.tax = Util.toFixed(total * Data.tax);
      resv.spaOptOut = this.spaOptOut(roomId, spa);
      resv.charge = Util.toFixed(total + parseFloat(resv.tax) - resv.spaOptOut);
      resv.paid = 0;
      resv.balance = 0;
      resv.cust = cust;
      resv.payments = payments;
      this.updateDaysFromResv(resv);
      return resv;
    };

    Res.prototype.copyResv = function(r) {
      var c;
      c = Object.assign({}, r);
      c.cust = Object.assign({}, r.cust);
      c.payments = Object.assign({}, r.payments);
      return c;
    };

    Res.prototype.createCust = function(first, last, phone, email, source) {
      var cust;
      cust = {};
      cust.custId = Data.genCustId(phone);
      cust.first = first;
      cust.last = last;
      cust.phone = phone;
      cust.email = email;
      cust.source = source;
      return cust;
    };

    Res.prototype.createPayment = function(amount, method, last4, purpose) {
      var payment;
      payment = {};
      payment.amount = amount;
      payment.date = Data.today();
      payment.method = method;
      payment["with"] = method;
      payment.last4 = last4;
      payment.purpose = purpose;
      payment.cc = '';
      payment.exp = '';
      payment.cvc = '';
      return payment;
    };

    Res.prototype.onRes = function(op, doRes) {
      return this.store.on('Res', op, 'none', (function(_this) {
        return function(resId, res) {
          return doRes(resId, res);
        };
      })(this));
    };

    Res.prototype.onDay = function(op, doDay) {
      return this.store.on('Day', op, 'none', (function(_this) {
        return function(dayId, day) {
          return doDay(dayId, day);
        };
      })(this));
    };

    Res.prototype.insert = function(table, rows, onComplete) {
      if (onComplete == null) {
        onComplete = null;
      }
      this.store.subscribe(table, 'insert', 'none', (function(_this) {
        return function(rows) {
          if (Util.isFunc(onComplete)) {
            return onComplete(rows);
          }
        };
      })(this));
      this.store.insert(table, rows);
    };

    Res.prototype.select = function(table, rows, onComplete) {
      if (onComplete == null) {
        onComplete = null;
      }
      this.store.subscribe(table, 'select', 'none', (function(_this) {
        return function(rows) {
          if (Util.isFunc(onComplete)) {
            return onComplete(rows);
          }
        };
      })(this));
      this.store.select(table);
    };

    Res.prototype.make = function(table, rows, onComplete) {
      if (onComplete == null) {
        onComplete = null;
      }
      this.store.subscribe(table, 'make', 'none', (function(_this) {
        return function() {
          return _this.insert(table, rows, Util.isFunc(onComplete) ? onComplete() : void 0);
        };
      })(this));
      this.store.make(table);
    };


    /*
    makeTables:() ->
      @make( 'Room', Res.Rooms )
      @store.make( 'Res' )
      @store.make( 'Day' )
      return
    
     * Destroys whole data base up to root
    dropMakeTable:( table ) ->
      @store.subscribe( table, 'drop', 'none', () => @store.make(table) )
      @store.drop( table )
      return
     */

    Res.prototype.setResvStatus = function(resv, post, purpose) {
      if (post === 'post') {
        if (purpose === 'PayInFull' || purpose === 'Complete') {
          resv.status = 'Skyline';
        }
        if (purpose === 'Deposit') {
          resv.status = 'Deposit';
        }
      } else if (post === 'deny') {
        resv.status = 'Free';
      }
      if (!Util.inArray(Data.statuses, resv.status)) {
        Util.error('Pay.setResStatus() unknown status ', resv.status);
        resv.status = 'Free';
      }
      return resv.status;
    };

    Res.prototype.addResv = function(resv) {
      this.resvs[resv.resId] = resv;
      this.updateDaysFromResv(resv);
      this.store.add('Res', resv.resId, resv);
    };

    Res.prototype.putResv = function(resv) {
      this.resvs[resv.resId] = resv;
      this.updateDaysFromResv(resv);
      this.store.put('Res', resv.resId, resv);
    };

    Res.prototype.delResv = function(resv) {
      delete this.resvs[resv.resId];
      this.deleteDaysFromResv(resv);
      this.store.del('Res', resv.resId);
    };

    Res.prototype.addCan = function(can) {
      can['cancel'] = this.today;
      this.cans[can.resId] = can;
      this.deleteDaysFromResv(can);
      this.store.add('Can', can.resId, can);
    };

    Res.prototype.putCan = function(can) {
      this.resvs[can.resId] = can;
      this.store.put('Can', can.resId, can);
    };

    Res.prototype.delCan = function(can) {
      delete this.cans[can.resId];
      this.store.del('Can', can.resId);
    };

    Res.prototype.addDay = function(day) {
      if (day.status !== 'Unknown') {
        this.days[day.dayId] = day;
        this.store.add('Day', day.dayId, day);
      } else {
        Util.error('Unknown day', day);
        Util.error('Checkon res', this.resvs[day.resId]);
      }
    };

    Res.prototype.putDay = function(day) {
      this.days[day.dayId] = day;
      this.store.put('Day', day.dayId, day);
    };

    Res.prototype.delDay = function(day) {
      delete this.days[day.dayId];
      this.store.del('Day', day.dayId);
    };

    Res.prototype.postPayment = function(resv, post, amount, method, last4, purpose) {
      var payId, status;
      status = this.setResvStatus(resv, post, purpose);
      if (status === 'Skyline' || status === 'Deposit') {
        payId = Data.genPaymentId(resv.resId, resv.payments);
        resv.payments[payId] = this.createPayment(amount, method, last4, purpose);
        resv.paid += amount;
        resv.balance = resv.totals - resv.paid;
        this.postResv(resv);
      }
    };

    Res.prototype.setDay = function(day, status, resId, dayId) {
      day.status = status;
      day.resId = resId;
      day.dayId = dayId;
      return day;
    };

    Res.prototype.optSpa = function(roomId) {
      return this.rooms[roomId].spa === 'O';
    };

    Res.prototype.hasSpa = function(roomId) {
      return this.rooms[roomId].spa === 'O' || this.rooms[roomId].spa === 'Y';
    };

    Res.prototype.resvArrayByDate = function(date) {
      var array, dayId, j, len, ref, resId, roomId;
      array = [];
      ref = this.roomKeys;
      for (j = 0, len = ref.length; j < len; j++) {
        roomId = ref[j];
        dayId = Data.dayId(date, roomId);
        if (this.days[dayId] != null) {
          resId = this.days[dayId].resId;
          if (this.resvs[resId] != null) {
            array.push(this.resvs[resId]);
          }
        }
      }
      return array;
    };

    Res.prototype.resvArrayByProp = function(beg, end, prop) {
      var array, date, dayId, j, len, ref, resId, resv, resvs, roomId;
      if (!((beg != null) && (end != null))) {
        return [];
      }
      resvs = {};
      array = [];
      ref = this.roomKeys;
      for (j = 0, len = ref.length; j < len; j++) {
        roomId = ref[j];
        date = beg;
        while (date <= end) {
          dayId = Data.dayId(date, roomId);
          if (this.days[dayId] != null) {
            resId = this.days[dayId].resId;
            if (this.resvs[resId] != null) {
              resvs[resId] = this.resvs[resId];
            }
          }
          date = Data.advanceDate(date, 1);
        }
      }
      for (resId in resvs) {
        if (!hasProp.call(resvs, resId)) continue;
        resv = resvs[resId];
        array.push(resv);
      }
      this.order = this.order === 'Decend' ? 'Ascend' : 'Decend';
      if (prop === 'stayto') {
        this.order = 'Ascend';
      }
      return Util.quicksort(array, prop, this.order);
    };

    Res.prototype.resvArrayDepart = function() {
      var array, beg, end, ref, resId, resv;
      array = [];
      beg = Data.toDateStr(1);
      end = Data.toDateStr(Data.numDaysMonth());
      ref = this.resvs;
      for (resId in ref) {
        resv = ref[resId];
        if (beg <= resv.depart && resv.depart <= end) {
          array.push(resv);
        }
      }
      return Util.quicksort(array, 'depart', 'Ascend');
    };

    Res.prototype.resvSortDebug = function(array, prop, order) {
      var i, j, k, ref, ref1;
      for (i = j = 0, ref = array.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        Util.log(array[i][prop]);
      }
      array = Util.quicksort(array, prop, order);
      Util.log('------ Res.sortArray() end');
      for (i = k = 0, ref1 = array.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
        Util.log(array[i][prop]);
      }
      return array;
    };

    return Res;

  })();

}).call(this);
